# 🚀 동기 / 비동기 / 블로킹 / 논블로킹 고도화 활용 전략

---

## 🧠 핵심 목적

> 단순 개념 이해를 넘어, **대규모 시스템 설계/운영에서 동기·비동기 개념을 어떻게 최적화하여 활용할 수 있는가**에 초점을 둡니다.

---

## 📦 고도화 활용 전략 요약

| 전략 | 설명 | 적용 사례 |
|------|------|-----------|
| 🧵 스레드 자원 최소화 | 동기/블로킹 방식은 스레드를 낭비하기 쉬움 → 비동기/논블로킹으로 전환 | 고성능 웹 서버 |
| ⏳ I/O 병목 분리 | DB, 외부 API 호출 등 느린 I/O를 비동기로 격리 | 마이크로서비스 연동 |
| 🔀 이벤트 기반 아키텍처 | 각 컴포넌트 간 동기 호출 대신 이벤트/메시지 큐 활용 | Kafka, RabbitMQ |
| 🧮 Future/Promise 병렬 조합 | 동시에 여러 비동기 작업을 실행하고 결과를 조합 | 이미지 처리, 배치 계산 |
| 🧩 하이브리드 처리 | 중요한 요청은 동기, 부가작업은 비동기 처리 | 결제 후 알림 전송 등 |

---

## 🧱 아키텍처 패턴으로 보는 고도화

### 1️⃣ Reactive Architecture

- **비동기 + 논블로킹 기반 설계**
- 데이터 흐름을 스트림으로 표현
- 자원 효율 + 응답성 + 복원력 (Resilience) 강화

**사용 예시**:
- Spring WebFlux (Java)
- RxJS (JS)
- Project Reactor

```java
Mono.just("요청")
    .map(req -> 서비스.처리(req))
    .subscribe(result -> 응답처리(result));
```

---

### 2️⃣ 이벤트 기반 시스템

- 컴포넌트 간 동기 호출 대신 메시지 큐로 통신
- **느린 서비스/외부 API는 이벤트 소비자로 처리**

**사용 도구**: Kafka, RabbitMQ, AWS SNS/SQS

```
[API 요청] ──> [이벤트 발행] ──> [비동기 소비자] ──> [DB 저장/메일 전송]
```

---

### 3️⃣ 비동기 + 블로킹 위험 피하기

> ⚠️ `CompletableFuture.get()` 또는 `await()` 등은 자칫 전체 시스템을 병목시킬 수 있음

**개선 방식**:

| Before | After |
|--------|-------|
| `future.get()` | `future.thenApply(...)` |
| `await result` | `callback` 또는 `observer` 방식 |

---

### 4️⃣ 병렬 비동기 실행 → 결과 조합 (Fan-out / Fan-in 패턴)

**예: 외부 API 3곳 동시에 호출 후 결과 합산**

```java
CompletableFuture<Result1> r1 = callAPI1();
CompletableFuture<Result2> r2 = callAPI2();
CompletableFuture<Result3> r3 = callAPI3();

CompletableFuture<Void> all = CompletableFuture.allOf(r1, r2, r3);
all.thenRun(() -> {
  combine(r1.join(), r2.join(), r3.join());
});
```

---

### 5️⃣ 비동기 백오프 & 재시도 전략

| 전략 | 설명 |
|------|------|
| Retry | 일정 횟수 재시도 (ex: 3회까지) |
| Exponential Backoff | 1s → 2s → 4s 등 점점 기다리기 |
| Circuit Breaker | 실패율 높으면 잠시 호출 차단 (Hystrix, Resilience4j) |

**💡 고도화 핵심은 "실패를 견디는 설계"**

---

## 🔧 기술 선택 기준

| 요구사항 | 추천 방식 | 설명 |
|----------|------------|------|
| 고성능 트래픽 처리 | 비동기 + 논블로킹 | 이벤트 기반 서버, API Gateway |
| 실시간 응답 중요 | 논블로킹 | 스트리밍, 채팅, 실시간 대시보드 |
| 데이터 정확성 우선 | 동기 + 블로킹 or 트랜잭션 보장 | 금융, 결제 등 |
| 부하 분산 | 메시지 큐 기반 비동기 분산 처리 | Kafka, SQS 등 |

---

## 📊 실무 적용 시 주의사항

- ✅ **ThreadPool 크기 제한 필수** (비동기라도 풀 고갈되면 블로킹됨)
- ✅ **시간 초과(timeout)** 반드시 설정 (응답 없으면 시스템 전체 대기 위험)
- ✅ **모니터링/로깅 체계 마련** (비동기 흐름은 디버깅 어려움)
- ✅ **비즈니스 우선순위 고려한 설계** (모든 걸 비동기로 만들 필요 없음)

---

## ✅ 요약

> 동기/비동기/블로킹/논블로킹 개념은  
> **단순 기술 선택이 아니라 아키텍처 설계 철학**입니다.

- 고성능 시스템 → **비동기 + 논블로킹 기반 아키텍처**
- 사용자 중심 서비스 → **응답 우선 처리 + 이벤트 분산**
- 실패 견디는 시스템 → **재시도, 백오프, 서킷 브레이커**

**단순 개념 이해에서 벗어나, 상황별로 전략적으로 조합하고 관리하는 것이 고도화의 핵심입니다.**
